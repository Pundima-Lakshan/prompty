package models

import (
	"fmt"
	"prompty/internal/ui/styles"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// AppState represents the current active screen/state of the application.
type AppState int

const (
	SearchState  AppState = iota // 0: Search screen (now includes browsing/tagging)
	BrowseState                  // 1: File browser screen (now for reviewing tagged files)
	ComposeState                 // 2: Prompt composition screen
)

// TaggedFilesMsg is a custom message type sent from SearchModel (or BrowseModel) to App
// when the list of tagged files changes. It carries the updated list of FileItem.
type TaggedFilesMsg []FileItem

// UntagFileMsg is a custom message sent from BrowseModel to App when a file is untagged.
// This is needed to propagate the untagging action back to the SearchModel, which holds
// the primary source of truth for all files and their tagged status.
type UntagFileMsg struct {
	Path string
}

// App is the main application model that holds the state of the entire CLI tool.
// It manages the different sub-models (Search, Browse, Compose) and their interactions.
type App struct {
	state  AppState // Current active application state (Search, Browse, or Compose)
	width  int      // Current terminal width
	height int      // Current terminal height

	searchModel  *SearchModel  // Model for the search functionality (now with integrated browsing)
	browseModel  *BrowseModel  // Model for reviewing tagged files
	composeModel *ComposeModel // Model for prompt composition

	// currentTaggedFiles stores the aggregated list of FileItem objects that have been tagged
	// across the application. This is the source of truth passed to ComposeModel and BrowseModel.
	currentTaggedFiles []FileItem
}

// NewApp creates and initializes a new App model.
// It sets the initial state to Search and initializes all sub-models.
func NewApp() *App {
	return &App{
		state:        SearchState,       // Start in the Search state
		searchModel:  NewSearchModel(),  // Initialize SearchModel
		browseModel:  NewBrowseModel(),  // Initialize BrowseModel
		composeModel: NewComposeModel(), // Initialize ComposeModel
		// Initializing slice to empty, not nil, for safety
		currentTaggedFiles: []FileItem{},
	}
}

// Init initializes the application.
// For the main app, there are no initial commands to run.
func (m *App) Init() tea.Cmd {
	return nil
}

// Update handles messages for the main App model.
// It acts as a central dispatcher, forwarding messages to the currently active
// sub-model and handling state transitions and inter-model communication.
func (m *App) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd         // Command to be returned from the active sub-model
	var internalCmd tea.Cmd // Command generated by App itself (e.g., for model updates)

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		// When the terminal window size changes, update the app's dimensions.
		m.width = msg.Width
		m.height = msg.Height
		// No need to pass this down directly to sub-models unless they specifically
		// need to react to window size changes (e.g., for dynamic layout adjustments).
		return m, nil

	case tea.KeyMsg:
		// Handle global key presses (like Ctrl+C for quit, or tab navigation).
		switch msg.String() {
		case "ctrl+c":
			// Quit the application.
			return m, tea.Quit

		case "1":
			// Switch to Search state (tab 1).
			m.state = SearchState
			// No specific update needed for searchModel when activating it as it's real-time.
			return m, nil
		case "2":
			// Switch to Browse state (tab 2).
			m.state = BrowseState
			// When navigating to browse, ensure it has the latest tagged files from search.
			internalCmd = m.browseModel.SetTaggedFiles(m.currentTaggedFiles)
			return m, internalCmd
		case "3":
			// Switch to Compose state (tab 3).
			m.state = ComposeState
			// When navigating to compose, ensure it has the latest tagged files.
			internalCmd = m.composeModel.SetSelectedFiles(m.currentTaggedFiles)
			return m, internalCmd

		case "tab":
			// Navigate forward between states (tabs).
			switch m.state {
			case SearchState:
				m.state = BrowseState
				internalCmd = m.browseModel.SetTaggedFiles(m.currentTaggedFiles)
			case BrowseState:
				m.state = ComposeState
				internalCmd = m.composeModel.SetSelectedFiles(m.currentTaggedFiles)
			case ComposeState:
				m.state = SearchState
			}
			return m, internalCmd

		case "shift+tab":
			// Navigate backward between states (tabs).
			switch m.state {
			case SearchState:
				m.state = ComposeState
				internalCmd = m.composeModel.SetSelectedFiles(m.currentTaggedFiles)
			case BrowseState:
				m.state = SearchState
			case ComposeState:
				m.state = BrowseState
				internalCmd = m.browseModel.SetTaggedFiles(m.currentTaggedFiles)
			}
			return m, internalCmd
		}

	case TaggedFilesMsg: // Message received from SearchModel when tagged files change.
		m.currentTaggedFiles = msg // Store the latest list of tagged files.
		// Propagate the updated tagged files to the ComposeModel immediately.
		composeCmd := m.composeModel.SetSelectedFiles(m.currentTaggedFiles)
		// If in Browse state, also update BrowseModel.
		if m.state == BrowseState {
			browseCmd := m.browseModel.SetTaggedFiles(m.currentTaggedFiles)
			return m, tea.Batch(composeCmd, browseCmd)
		}
		return m, composeCmd // Otherwise, just update ComposeModel.

	case UntagFileMsg: // Message received from BrowseModel when a file is untagged.
		// Find the file in SearchModel's results and update its tagged status.
		// This ensures SearchModel remains the source of truth for all file tags.
		for i := range m.searchModel.results {
			if m.searchModel.results[i].Path == msg.Path {
				m.searchModel.results[i].Tagged = false
				break
			}
		}
		// Re-fetch tagged files from SearchModel to update currentTaggedFiles.
		m.currentTaggedFiles = m.searchModel.GetTaggedFiles()
		// Propagate the updated tagged files to ComposeModel and BrowseModel.
		composeCmd := m.composeModel.SetSelectedFiles(m.currentTaggedFiles)
		browseCmd := m.browseModel.SetTaggedFiles(m.currentTaggedFiles) // Update BrowseModel to reflect the untag
		return m, tea.Batch(composeCmd, browseCmd)
	}

	// If the message was not handled by the App model,
	// delegate it to the currently active sub-model for processing.
	switch m.state {
	case SearchState:
		var searchModel tea.Model
		searchModel, cmd = m.searchModel.Update(msg)
		m.searchModel = searchModel.(*SearchModel) // Type assertion back to *SearchModel
	case BrowseState:
		var browseModel tea.Model
		browseModel, cmd = m.browseModel.Update(msg)
		m.browseModel = browseModel.(*BrowseModel) // Type assertion back to *BrowseModel
	case ComposeState:
		var composeModel tea.Model
		composeModel, cmd = m.composeModel.Update(msg)
		m.composeModel = composeModel.(*ComposeModel) // Type assertion back to *ComposeModel
	}

	// Return the updated App model and any command from the sub-model.
	return m, cmd
}

// View renders the main application interface, including the header, tabs,
// and the view of the currently active sub-model.
func (m *App) View() string {
	// Render the application header.
	header := styles.HeaderStyle.Render("üîç Prompt Generator")

	// Render the tab bar for navigation.
	tabs := m.renderTabs()

	// Get the view string from the currently active sub-model.
	var content string
	switch m.state {
	case SearchState:
		content = m.searchModel.View()
	case BrowseState:
		content = m.browseModel.View()
	case ComposeState:
		content = m.composeModel.View()
	}

	// Render the global help text.
	// Updated to reflect Ctrl+Q as quit key
	help := styles.HelpStyle.Render("1,2,3: Jump to tab ‚Ä¢ Tab/Shift+Tab: Navigate ‚Ä¢ Ctrl+Q/Ctrl+C: Quit")

	// Join all elements vertically to form the complete application layout.
	main := lipgloss.JoinVertical(
		lipgloss.Left, // Align content to the left
		header,
		"", // Spacer
		tabs,
		"", // Spacer
		content,
		"", // Spacer
		help,
	)

	// Apply base styling and size constraints to the entire application view.
	return styles.BaseStyle.
		Width(m.width - 4).   // Set width, accounting for padding/borders
		Height(m.height - 4). // Set height, accounting for padding/borders
		Render(main)
}

// renderTabs generates the styled tab bar for navigation between states.
func (m *App) renderTabs() string {
	var tabs []string

	// Search Tab
	searchIcon := "üîç"
	searchText := " Search "
	if m.state == SearchState {
		tabs = append(tabs, styles.SearchTabStyle.Render(searchIcon+searchText))
	} else {
		tabs = append(tabs, styles.InactiveTabStyle.Render(searchIcon+searchText))
	}

	// Browse Tab
	browseIcon := "üìÅ"
	browseText := " Browse "
	// Get the current count of tagged files from the App model's source of truth.
	taggedCount := len(m.currentTaggedFiles)
	if taggedCount > 0 {
		browseText = fmt.Sprintf(" Browse (%d) ", taggedCount)
	}
	if m.state == BrowseState {
		tabs = append(tabs, styles.BrowseTabStyle.Render(browseIcon+browseText))
	} else {
		// If not active, but files are tagged, show a different color to indicate activity.
		if taggedCount > 0 {
			taggedStyle := styles.InactiveTabStyle.Copy().
				Foreground(styles.SecondaryColor). // Use secondary color for tagged indication
				Bold(true)
			tabs = append(tabs, taggedStyle.Render(browseIcon+browseText))
		} else {
			tabs = append(tabs, styles.InactiveTabStyle.Render(browseIcon+browseText))
		}
	}

	// Compose Tab
	composeIcon := "‚úçÔ∏è"
	composeText := " Compose "
	if m.state == ComposeState {
		tabs = append(tabs, styles.ComposeTabStyle.Render(composeIcon+composeText))
	} else {
		tabs = append(tabs, styles.InactiveTabStyle.Render(composeIcon+composeText))
	}

	// Join all individual tabs horizontally.
	tabBar := lipgloss.JoinHorizontal(lipgloss.Top, tabs...)

	// Add a hint for keyboard shortcuts to jump to tabs.
	shortcutHint := styles.HelpStyle.Render("   1,2,3: Jump to tab")
	tabBarWithHint := lipgloss.JoinHorizontal(
		lipgloss.Top,
		tabBar,
		"    ", // Spacer for visual separation
		shortcutHint,
	)

	// Render the complete tab bar with its border.
	return styles.TabBarStyle.Render(tabBarWithHint)
}
